{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "line-matching-game",
  "type": "registry:component",
  "title": "Line Matching Game",
  "description": "An interactive line matching game using React Flow.",
  "dependencies": [
    "@xyflow/react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/line-matching-game/line-matching-game.tsx",
      "content": "\"use client\";\n\nimport {\n  ReactFlow,\n  Controls,\n  Connection,\n  addEdge,\n  getConnectedEdges,\n  Edge,\n  reconnectEdge,\n  Node,\n} from \"@xyflow/react\";\nimport \"@xyflow/react/dist/style.css\";\nimport { DefinitionNode, LabelNode, CustomNodeDataType } from \"./custom-node\";\nimport { useCallback, useState } from \"react\";\nimport { initNodes, checkCorrectConnection } from \"./utils\";\nimport { DATA } from \"./constants\";\nimport { CustomColorEdge } from \"./custom-edge\";\nimport { GameControll } from \"./game-controll\";\n\nconst nodeTypes = {\n  labelNode: LabelNode,\n  definitionNode: DefinitionNode,\n};\n\nconst edgeTypes = {\n  customColorEdge: CustomColorEdge,\n};\n\nexport const LineMatchingGame = () => {\n  const [nodes, setNodes] = useState<Node[]>(() => {\n    return initNodes(DATA);\n  });\n  const [edges, setEdges] = useState<Edge[]>([]);\n  const [result, setResult] = useState<{\n    isCorrect: boolean;\n    correctCount: number;\n    totalCount: number;\n  } | null>(null);\n\n  const onConnect = (connection: Connection) => {\n    const { source, target } = connection;\n    const targetNode = nodes.find((node) => node.id === target);\n    const sourceNode = nodes.find(\n      (node) => node.id === source\n    ) as Node<CustomNodeDataType>;\n    if (!sourceNode || !targetNode) return;\n\n    const color = sourceNode.data.color;\n    const targetNodeElement = document.querySelector(\n      `[data-id='${targetNode.id}']`\n    ) as HTMLElement;\n    if (!targetNodeElement) return;\n    console.log(\"targetNodeElement\", targetNodeElement);\n    targetNodeElement.style.setProperty(\"border-color\", color);\n\n    const connectedEdges = getConnectedEdges([sourceNode, targetNode], edges);\n    setEdges((eds) =>\n      addEdge(connection, eds).filter((edge) => !connectedEdges.includes(edge))\n    );\n    setNodes((nds) => nds.map((node) => ({ ...node })));\n  };\n\n  const onReconnect = useCallback(\n    (oldEdge: Edge, newConnection: Connection) => {\n      setEdges((els) => reconnectEdge(oldEdge, newConnection, els));\n    },\n    []\n  );\n\n  const checkAnswers = () => {\n    const checkResult = checkCorrectConnection(nodes, edges, DATA);\n    setResult(checkResult);\n\n    // Visual feedback for correct/incorrect connections\n    edges.forEach((edge) => {\n      const labelIndex = parseInt(edge.source.replace(\"label-\", \"\"));\n      const definitionIndex = parseInt(edge.target.replace(\"definition-\", \"\"));\n      const isCorrect = labelIndex === definitionIndex;\n\n      const targetNodeElement = document.querySelector(\n        `[data-id='${edge.target}']`\n      ) as HTMLElement;\n\n      if (targetNodeElement) {\n        // Add visual feedback based on correctness\n        if (isCorrect) {\n          targetNodeElement.style.setProperty(\"border-color\", \"green\");\n        } else {\n          targetNodeElement.style.setProperty(\"border-color\", \"red\");\n        }\n      }\n    });\n\n    return checkResult;\n  };\n\n  const reset = () => {\n    setNodes(initNodes(DATA));\n    setEdges([]);\n    setResult(null);\n  };\n\n  return (\n    <div className=\"w-full\">\n      <div className=\"h-200 w-full\">\n        <ReactFlow\n          className=\"w-full\"\n          nodeTypes={nodeTypes}\n          edgeTypes={edgeTypes}\n          nodes={nodes}\n          edges={edges}\n          onConnect={onConnect}\n          onReconnect={onReconnect}\n          fitView\n          panOnDrag={false}\n          panOnScroll={false}\n          zoomOnScroll={false}\n          zoomOnPinch={false}\n          zoomOnDoubleClick={false}\n        >\n          <Controls />\n        </ReactFlow>\n      </div>\n      <GameControll checkAnswers={checkAnswers} reset={reset} result={result} />\n    </div>\n  );\n};\n",
      "type": "registry:block"
    },
    {
      "path": "registry/new-york/blocks/line-matching-game/custom-node.tsx",
      "content": "import { NodeProps, Position, Handle, useNodeConnections } from \"@xyflow/react\";\n\nexport type CustomNodeDataType = {\n  content: string;\n  color: string;\n};\n\nexport const LabelNode = (props: NodeProps) => {\n  const { data } = props;\n  const { content, color } = data as CustomNodeDataType;\n  return (\n    <div\n      className={`rounded-lg border-2 border-b-4 p-3 w-80`}\n      style={{\n        borderColor: color,\n      }}\n    >\n      {content}\n      <Handle\n        type=\"source\"\n        position={Position.Right}\n        className=\"!size-3\"\n        style={{\n          background: color,\n        }}\n        data-color={color}\n      />\n    </div>\n  );\n};\n\nexport const DefinitionNode = (props: NodeProps) => {\n  const { data } = props;\n  const { content, color } = data as CustomNodeDataType;\n  return (\n    <div\n      className={`rounded-lg border-2 border-b-4 p-3 w-100 border-gray-300`}\n      style={{\n        borderColor: color || \"gray\",\n      }}\n    >\n      {content}\n      <Handle\n        type=\"target\"\n        position={Position.Left}\n        className=\"!size-3 background-gray-300\"\n        isConnectableStart={false}\n        style={{\n          background: color || \"gray\",\n        }}\n      />\n    </div>\n  );\n};\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/line-matching-game/utils.ts",
      "content": "import { colors } from \"./constants\";\nimport { Edge, Node } from \"@xyflow/react\";\n\nexport const createRandomPositionIndex = (n: number): number[] => {\n  if (n === 0) return [];\n  const indices = Array.from({ length: n }, (_, i) => i);\n  for (let i = n - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [indices[i], indices[j]] = [indices[j], indices[i]];\n  }\n  return indices;\n};\n\nexport const initNodes = (data: { label: string; definition: string }[]) => {\n  const result: Node[] = [];\n  const totalPairs = data.length;\n  const defPositionIndices = createRandomPositionIndex(totalPairs);\n\n  data.forEach((item, index) => {\n    const color = colors[index % colors.length].color;\n    result.push({\n      id: `label-${index}`,\n      type: \"labelNode\",\n      position: { x: -200, y: index * 100 },\n      data: { content: item.label, color },\n      draggable: false,\n    });\n    const defYIndex = defPositionIndices[index];\n    result.push({\n      id: `definition-${defYIndex}`,\n      type: \"definitionNode\",\n      position: { x: 200, y: defYIndex * 100 },\n      data: { content: item.definition },\n      draggable: false,\n    });\n  });\n\n  return result;\n};\n\nexport const checkCorrectConnection = (\n  nodes: Node[],\n  edges: Edge[],\n  data: { label: string; definition: string }[]\n): { isCorrect: boolean; correctCount: number; totalCount: number } => {\n  let correctCount = 0;\n  const totalCount = edges.length;\n\n  edges.forEach((edge) => {\n    const { source, target } = edge;\n\n    // Extract index from source (label-0, label-1, etc.)\n    const labelIndex = parseInt(source.replace(\"label-\", \"\"));\n\n    // Extract index from target (definition-0, definition-1, etc.)\n    const definitionIndex = parseInt(target.replace(\"definition-\", \"\"));\n\n    // Check if this connection matches the original data\n    // The label at labelIndex should match the definition at definitionIndex\n    if (\n      labelIndex >= 0 &&\n      labelIndex < data.length &&\n      definitionIndex >= 0 &&\n      definitionIndex < data.length &&\n      labelIndex === definitionIndex\n    ) {\n      correctCount++;\n    }\n  });\n\n  return {\n    isCorrect: correctCount === data.length && totalCount === data.length,\n    correctCount,\n    totalCount,\n  };\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/line-matching-game/constants.ts",
      "content": "export const colors = [\n  {\n    color: \"#8B5CF6\",\n    border: \"#9746FF\",\n    shadow: \"0px 5px 0px 0px #9746FF\",\n  },\n  {\n    color: \"#027BE5\",\n    border: \"#027BE5\",\n    shadow: \"0px 5px 0px 0px #027BE5\",\n  },\n  {\n    color: \"#FFB800\",\n    border: \"#FFB800\",\n    shadow: \"0px 5px 0px 0px #FFB800\",\n  },\n  {\n    color: \"#FF23BD\",\n    border: \"#FF23BD\",\n    shadow: \"0px 5px 0px 0px #FF23BD\",\n  },\n  {\n    color: \"#49C5B1\",\n    border: \"#49C5B1\",\n    shadow: \"0px 5px 0px 0px #49C5B1\",\n  },\n  {\n    color: \"#667799\",\n    border: \"#667799\",\n    shadow: \"0px 5px 0px 0px #667799\",\n  },\n  {\n    color: \"#FF5733\",\n    border: \"#FF5733\",\n    shadow: \"0px 5px 0px 0px #FF5733\",\n  },\n  {\n    color: \"#33FF57\",\n    border: \"#33FF57\",\n    shadow: \"0px 5px 0px 0px #33FF57\",\n  },\n  {\n    color: \"#3357FF\",\n    border: \"#3357FF\",\n    shadow: \"0px 5px 0px 0px #3357FF\",\n  },\n  {\n    color: \"#FF33A1\",\n    border: \"#FF33A1\",\n    shadow: \"0px 5px 0px 0px #FF33A1\",\n  },\n  {\n    color: \"#A133FF\",\n    border: \"#A133FF\",\n    shadow: \"0px 5px 0px 0px #A133FF\",\n  },\n  {\n    color: \"#33FFDD\",\n    border: \"#33FFDD\",\n    shadow: \"0px 5px 0px 0px #33FFDD\",\n  },\n  {\n    color: \"#FFDD33\",\n    border: \"#FFDD33\",\n    shadow: \"0px 5px 0px 0px #FFDD33\",\n  },\n  {\n    color: \"#8D33FF\",\n    border: \"#8D33FF\",\n    shadow: \"0px 5px 0px 0px #8D33FF\",\n  },\n  {\n    color: \"#338DFF\",\n    border: \"#338DFF\",\n    shadow: \"0px 5px 0px 0px #338DFF\",\n  },\n  {\n    color: \"#FF338D\",\n    border: \"#FF338D\",\n    shadow: \"0px 5px 0px 0px #FF338D\",\n  },\n  {\n    color: \"#33FF8D\",\n    border: \"#33FF8D\",\n    shadow: \"0px 5px 0px 0px #33FF8D\",\n  },\n  {\n    color: \"#8DFF33\",\n    border: \"#8DFF33\",\n    shadow: \"0px 5px 0px 0px #8DFF33\",\n  },\n  {\n    color: \"#FF8D33\",\n    border: \"#FF8D33\",\n    shadow: \"0px 5px 0px 0px #FF8D33\",\n  },\n  {\n    color: \"#00CED1\",\n    border: \"#00CED1\",\n    shadow: \"0px 5px 0px 0px #00CED1\",\n  },\n  {\n    color: \"#BA55D3\",\n    border: \"#BA55D3\",\n    shadow: \"0px 5px 0px 0px #BA55D3\",\n  },\n  {\n    color: \"#7B68EE\",\n    border: \"#7B68EE\",\n    shadow: \"0px 5px 0px 0px #7B68EE\",\n  },\n  {\n    color: \"#FF4500\",\n    border: \"#FF4500\",\n    shadow: \"0px 5px 0px 0px #FF4500\",\n  },\n  {\n    color: \"#DAA520\",\n    border: \"#DAA520\",\n    shadow: \"0px 5px 0px 0px #DAA520\",\n  },\n  {\n    color: \"#ADFF2F\",\n    border: \"#ADFF2F\",\n    shadow: \"0px 5px 0px 0px #ADFF2F\",\n  },\n  {\n    color: \"#20B2AA\",\n    border: \"#20B2AA\",\n    shadow: \"0px 5px 0px 0px #20B2AA\",\n  },\n  {\n    color: \"#8A2BE2\",\n    border: \"#8A2BE2\",\n    shadow: \"0px 5px 0px 0px #8A2BE2\",\n  },\n  {\n    color: \"#D2691E\",\n    border: \"#D2691E\",\n    shadow: \"0px 5px 0px 0px #D2691E\",\n  },\n  {\n    color: \"#5F9EA0\",\n    border: \"#5F9EA0\",\n    shadow: \"0px 5px 0px 0px #5F9EA0\",\n  },\n  {\n    color: \"#FF69B4\",\n    border: \"#FF69B4\",\n    shadow: \"0px 5px 0px 0px #FF69B4\",\n  },\n  {\n    color: \"#7FFF00\",\n    border: \"#7FFF00\",\n    shadow: \"0px 5px 0px 0px #7FFF00\",\n  },\n  {\n    color: \"#DC143C\",\n    border: \"#DC143C\",\n    shadow: \"0px 5px 0px 0px #DC143C\",\n  },\n  {\n    color: \"#00FFFF\",\n    border: \"#00FFFF\",\n    shadow: \"0px 5px 0px 0px #00FFFF\",\n  },\n  {\n    color: \"#FFD700\",\n    border: \"#FFD700\",\n    shadow: \"0px 5px 0px 0px #FFD700\",\n  },\n  {\n    color: \"#C71585\",\n    border: \"#C71585\",\n    shadow: \"0px 5px 0px 0px #C71585\",\n  },\n  {\n    color: \"#4682B4\",\n    border: \"#4682B4\",\n    shadow: \"0px 5px 0px 0px #4682B4\",\n  },\n  {\n    color: \"#9ACD32\",\n    border: \"#9ACD32\",\n    shadow: \"0px 5px 0px 0px #9ACD32\",\n  },\n  {\n    color: \"#F08080\",\n    border: \"#F08080\",\n    shadow: \"0px 5px 0px 0px #F08080\",\n  },\n  {\n    color: \"#40E0D0\",\n    border: \"#40E0D0\",\n    shadow: \"0px 5px 0px 0px #40E0D0\",\n  },\n  {\n    color: \"#EE82EE\",\n    border: \"#EE82EE\",\n    shadow: \"0px 5px 0px 0px #EE82EE\",\n  },\n];\n\nexport const DATA: {\n  label: string;\n  definition: string;\n}[] = [\n  {\n    label: \"Paulo Bento\",\n    definition:\n      \"Huấn luyện viên tin tưởng Nani từ khi còn ở học viện và giúp anh phát triển sự nghiệp.\",\n  },\n  {\n    label: \"Jose Peseiro\",\n    definition: \"Huấn luyện viên trao cơ hội ra mắt Champions League cho Nani.\",\n  },\n  {\n    label: \"Sir Alex Ferguson\",\n    definition:\n      \"Huấn luyện viên nghiêm khắc nhưng kỳ vọng lớn ở Nani tại Man United.\",\n  },\n  {\n    label: \"Cristiano Ronaldo\",\n    definition: \"Đồng đội giúp Nani vượt qua khó khăn ban đầu tại Man United.\",\n  },\n  {\n    label: \"Portugal Football Summit\",\n    definition:\n      \"Sự kiện bóng đá nơi Nani chia sẻ về những người thầy của mình.\",\n  },\n];\n",
      "type": "registry:lib"
    }
  ]
}